Status: 201
Response: [{"routine_name":"current_employee_from_token","routine_definition":"\r\nDECLARE\r\n  v_token_str TEXT;\r\n  v_token UUID;\r\nBEGIN\r\n  -- ✅ SOMENTE token do funcionário (NUNCA aceitar x-workspace-id)\r\n  v_token_str := current_setting('request.headers', true)::json->>'x-employee-token';\r\n\r\n  IF v_token_str IS NULL OR length(trim(v_token_str)) = 0 THEN\r\n    RETURN;\r\n  END IF;\r\n\r\n  BEGIN\r\n    v_token := v_token_str::UUID;\r\n  EXCEPTION WHEN OTHERS THEN\r\n    RETURN;\r\n  END;\r\n\r\n  RETURN QUERY\r\n  SELECT s.employee_id, e.workspace_id, e.roles\r\n  FROM public.employee_sessions s\r\n  JOIN public.employees e ON e.id = s.employee_id\r\n  WHERE s.token = v_token\r\n    AND s.revoked_at IS NULL\r\n    AND s.expires_at > now()\r\n  LIMIT 1;\r\nEND;\r\n"},{"routine_name":"get_dashboard_kpis","routine_definition":"\nDECLARE\n    v_workspace_id UUID;\n    v_user_id UUID;\n    v_role TEXT;\n    v_result JSONB;\nBEGIN\n    -- 1. SECURITY: Determine Workspace Context\n    v_role := auth.role();\n    v_user_id := auth.uid();\n\n    IF v_role = 'authenticated' THEN\n        -- Admin: Get workspace from workspace ownership\n        SELECT id INTO v_workspace_id FROM public.workspaces WHERE owner_id = v_user_id LIMIT 1;\n    ELSE\n        -- Employee (anon): Get workspace from Token\n        -- This function checks x-employee-token header and validates the session\n        SELECT workspace_id INTO v_workspace_id FROM public.current_employee_from_token();\n    END IF;\n\n    IF v_workspace_id IS NULL THEN\n        -- Fail safe\n        RAISE EXCEPTION 'Acesso negado: Workspace não identificado ou token inválido.';\n    END IF;\n\n    -- 2. QUERY LOGIC (Identical to original but enforcing v_workspace_id)\n    WITH filtered_tickets AS (\n        SELECT\n            t.*,\n            COALESCE(t.repair_end_at, CASE WHEN t.status = 'Finalizado' THEN t.updated_at ELSE NULL END) as effective_repair_end,\n            EXTRACT(EPOCH FROM (t.repair_end_at - t.repair_start_at)) as duration_repair_sec,\n            EXTRACT(EPOCH FROM (COALESCE(t.pickup_available_at, t.repair_end_at) - t.created_at)) as duration_solution_sec,\n            EXTRACT(EPOCH FROM (t.delivered_at - t.created_at)) as duration_delivery_sec,\n            EXTRACT(EPOCH FROM (t.budget_sent_at - t.created_at)) as duration_budget_sec,\n            EXTRACT(EPOCH FROM (t.pickup_available_at - t.created_at)) as duration_pickup_notify_sec\n        FROM\n            public.tickets t\n        WHERE\n            t.workspace_id = v_workspace_id -- ENFORCED HERE\n            AND t.deleted_at IS NULL\n            AND (p_date_start IS NULL OR t.created_at >= p_date_start::timestamp)\n            AND (p_date_end IS NULL OR t.created_at <= (p_date_end::timestamp + INTERVAL '1 day' - INTERVAL '1 millisecond'))\n            AND (p_technician_id IS NULL OR t.technician_id = p_technician_id)\n            AND (p_status IS NULL OR p_status = 'all' OR t.status = p_status)\n            AND (p_device_model IS NULL OR p_device_model = 'all' OR t.device_model = p_device_model)\n            AND (p_defect IS NULL OR p_defect = 'all' OR t.defect_reported ILIKE '%' || p_defect || '%')\n            AND (p_search IS NULL OR\n                 t.client_name ILIKE '%' || p_search || '%' OR\n                 t.os_number ILIKE '%' || p_search || '%' OR\n                 t.device_model ILIKE '%' || p_search || '%' OR\n                 t.serial_number ILIKE '%' || p_search || '%' OR\n                 t.contact_info ILIKE '%' || p_search || '%'\n            )\n    ),\n    expanded_defects AS (\n        SELECT\n            trim(defect) as defect_name,\n            repair_successful,\n            duration_repair_sec,\n            duration_solution_sec,\n            duration_delivery_sec,\n            device_model,\n            technician_id\n        FROM\n            filtered_tickets,\n            unnest(string_to_array(defect_reported, ',')) as defect\n        WHERE\n            trim(defect) <> ''\n    ),\n    stats AS (\n        SELECT\n            count(*) as total_tickets,\n            count(*) FILTER (WHERE status = 'Analise Tecnica') as analysis_count,\n            count(*) FILTER (WHERE status = 'Andamento Reparo') as repair_count,\n            count(*) FILTER (WHERE repair_successful IS NOT NULL) as total_with_outcome,\n            count(*) FILTER (WHERE repair_successful = TRUE) as success_count,\n            avg(duration_repair_sec) FILTER (WHERE duration_repair_sec > 0) as avg_repair_sec,\n            avg(duration_solution_sec) FILTER (WHERE duration_solution_sec > 0) as avg_solution_sec,\n            avg(duration_delivery_sec) FILTER (WHERE duration_delivery_sec > 0) as avg_delivery_sec,\n            avg(duration_budget_sec) FILTER (WHERE duration_budget_sec > 0) as avg_budget_sec,\n            avg(duration_pickup_notify_sec) FILTER (WHERE duration_pickup_notify_sec > 0) as avg_pickup_notify_sec,\n            count(*) FILTER (WHERE created_at >= (now() - INTERVAL '1 day')) as tickets_today,\n            count(*) FILTER (WHERE created_at >= (now() - INTERVAL '7 days')) as tickets_week,\n            count(*) FILTER (WHERE created_at >= (now() - INTERVAL '30 days')) as tickets_month,\n            count(*) FILTER (WHERE effective_repair_end >= (now() - INTERVAL '1 day')) as repairs_today,\n            count(*) FILTER (WHERE effective_repair_end >= (now() - INTERVAL '7 days')) as repairs_week,\n            count(*) FILTER (WHERE effective_repair_end >= (now() - INTERVAL '30 days')) as repairs_month,\n            count(*) FILTER (WHERE delivery_method = 'pickup') as pickup_total,\n            count(*) FILTER (WHERE delivery_method = 'pickup' AND repair_successful = TRUE) as pickup_success,\n            count(*) FILTER (WHERE delivery_method = 'pickup' AND repair_successful = FALSE) as pickup_fail,\n            count(*) FILTER (WHERE delivery_method = 'carrier') as carrier_total,\n            count(*) FILTER (WHERE delivery_method = 'carrier' AND repair_successful = TRUE) as carrier_success,\n            count(*) FILTER (WHERE delivery_method = 'carrier' AND repair_successful = FALSE) as carrier_fail,\n            count(*) FILTER (WHERE is_outsourced = TRUE) as outsourced_total,\n            count(*) FILTER (WHERE is_outsourced = TRUE AND repair_successful = TRUE) as outsourced_success,\n            count(*) FILTER (WHERE is_outsourced = TRUE AND repair_successful = FALSE) as outsourced_fail,\n            sum(COALESCE(outsourced_return_count, 0)) as outsourced_returns,\n            count(*) FILTER (WHERE is_outsourced = FALSE AND (technician_id IS NOT NULL OR status <> 'Aberto')) as internal_total,\n            count(*) FILTER (WHERE is_outsourced = FALSE AND (technician_id IS NOT NULL OR status <> 'Aberto') AND repair_successful = TRUE) as internal_success,\n            count(*) FILTER (WHERE is_outsourced = FALSE AND (technician_id IS NOT NULL OR status <> 'Aberto') AND repair_successful = FALSE) as internal_fail\n        FROM filtered_tickets\n    ),\n    top_defects AS (\n        SELECT defect_name as label, count(*) as total, count(*) FILTER (WHERE repair_successful = TRUE) as success, count(*) FILTER (WHERE repair_successful = FALSE) as fail, CASE WHEN count(*) > 0 THEN round((count(*) FILTER (WHERE repair_successful = TRUE)::numeric / count(*)) * 100) ELSE 0 END as \"successRate\", CASE WHEN count(*) > 0 THEN round((count(*) FILTER (WHERE repair_successful = FALSE)::numeric / count(*)) * 100) ELSE 0 END as \"failRate\" FROM expanded_defects GROUP BY defect_name ORDER BY total DESC\n    ),\n    top_models AS (\n        SELECT device_model as label, count(*) as total, count(*) FILTER (WHERE repair_successful = TRUE) as success, count(*) FILTER (WHERE repair_successful = FALSE) as fail, CASE WHEN count(*) > 0 THEN round((count(*) FILTER (WHERE repair_successful = TRUE)::numeric / count(*)) * 100) ELSE 0 END as \"successRate\", CASE WHEN count(*) > 0 THEN round((count(*) FILTER (WHERE repair_successful = FALSE)::numeric / count(*)) * 100) ELSE 0 END as \"failRate\" FROM filtered_tickets WHERE device_model IS NOT NULL GROUP BY device_model ORDER BY total DESC\n    ),\n    top_combos AS (\n        SELECT device_model || ' · ' || defect_name as label, count(*) as total, count(*) FILTER (WHERE repair_successful = TRUE) as success, count(*) FILTER (WHERE repair_successful = FALSE) as fail, CASE WHEN count(*) > 0 THEN round((count(*) FILTER (WHERE repair_successful = TRUE)::numeric / count(*)) * 100) ELSE 0 END as \"successRate\", CASE WHEN count(*) > 0 THEN round((count(*) FILTER (WHERE repair_successful = FALSE)::numeric / count(*)) * 100) ELSE 0 END as \"failRate\" FROM expanded_defects WHERE device_model IS NOT NULL GROUP BY device_model, defect_name ORDER BY total DESC\n    ),\n    tech_metrics AS (\n        SELECT t.technician_id, count(*) as total, count(*) FILTER (WHERE t.repair_successful IS NOT NULL) as completed, count(*) FILTER (WHERE t.repair_successful = TRUE) as success_count FROM filtered_tickets t WHERE t.technician_id IS NOT NULL GROUP BY t.technician_id\n    )\n    SELECT\n        jsonb_build_object(\n            'successRate', CASE WHEN (SELECT total_with_outcome FROM stats) > 0 THEN round(((SELECT success_count FROM stats)::numeric / (SELECT total_with_outcome FROM stats)) * 100) ELSE 0 END,\n            'avgRepair', COALESCE((SELECT avg_repair_sec FROM stats) * 1000, 0),\n            'avgSolution', COALESCE((SELECT avg_solution_sec FROM stats) * 1000, 0),\n            'avgDelivery', COALESCE((SELECT avg_delivery_sec FROM stats) * 1000, 0),\n            'avgBudget', COALESCE((SELECT avg_budget_sec FROM stats) * 1000, 0),\n            'avgPickupNotify', COALESCE((SELECT avg_pickup_notify_sec FROM stats) * 1000, 0),\n            'analysisCount', (SELECT analysis_count FROM stats),\n            'repairCount', (SELECT repair_count FROM stats),\n            'ticketsPerDay', CASE WHEN p_date_start IS NOT NULL AND p_date_end IS NOT NULL THEN round((SELECT total_tickets FROM stats)::numeric / GREATEST(1, EXTRACT(DAY FROM (p_date_end::timestamp - p_date_start::timestamp)))) ELSE 0 END,\n            'repairsToday', (SELECT repairs_today FROM stats),\n            'repairsWeek', (SELECT repairs_week FROM stats),\n            'repairsMonth', (SELECT repairs_month FROM stats),\n            'ticketsToday', (SELECT tickets_today FROM stats),\n            'ticketsWeek', (SELECT tickets_week FROM stats),\n            'ticketsMonth', (SELECT tickets_month FROM stats),\n            'topDefects', (SELECT COALESCE(jsonb_agg(d), '[]'::jsonb) FROM (SELECT * FROM top_defects) d),\n            'topModels', (SELECT COALESCE(jsonb_agg(m), '[]'::jsonb) FROM (SELECT * FROM top_models LIMIT 100) m),\n            'topCombos', (SELECT COALESCE(jsonb_agg(c), '[]'::jsonb) FROM (SELECT * FROM top_combos LIMIT 50) c),\n            'techStats', (SELECT COALESCE(jsonb_agg(t), '[]'::jsonb) FROM (SELECT tm.technician_id as id, e.name, tm.total, tm.completed, CASE WHEN tm.completed > 0 THEN round((tm.success_count::numeric / tm.completed) * 100) ELSE 0 END as \"successRate\" FROM tech_metrics tm LEFT JOIN public.employees e ON e.id = tm.technician_id ORDER BY tm.completed DESC) t),\n            'slowestModels', (SELECT COALESCE(jsonb_agg(x), '[]'::jsonb) FROM (SELECT device_model as label, avg(duration_repair_sec) * 1000 as \"avgTime\", count(*) as count FROM filtered_tickets WHERE duration_repair_sec > 0 GROUP BY device_model ORDER BY \"avgTime\" DESC LIMIT 5) x),\n            'slowestModelsSolution', (SELECT COALESCE(jsonb_agg(x), '[]'::jsonb) FROM (SELECT device_model as label, avg(duration_solution_sec) * 1000 as \"avgTime\", count(*) as count FROM filtered_tickets WHERE duration_solution_sec > 0 GROUP BY device_model ORDER BY \"avgTime\" DESC LIMIT 5) x),\n            'slowestModelsDelivery', (SELECT COALESCE(jsonb_agg(x), '[]'::jsonb) FROM (SELECT device_model as label, avg(duration_delivery_sec) * 1000 as \"avgTime\", count(*) as count FROM filtered_tickets WHERE duration_delivery_sec > 0 GROUP BY device_model ORDER BY \"avgTime\" DESC LIMIT 5) x),\n            'slowestDefects', (SELECT COALESCE(jsonb_agg(x), '[]'::jsonb) FROM (SELECT defect_name as label, avg(duration_repair_sec) * 1000 as \"avgTime\", count(*) as count FROM expanded_defects WHERE duration_repair_sec > 0 GROUP BY defect_name ORDER BY \"avgTime\" DESC LIMIT 5) x),\n            'slowestCombos', (SELECT COALESCE(jsonb_agg(x), '[]'::jsonb) FROM (SELECT device_model || ' - ' || defect_name as label, avg(duration_repair_sec) * 1000 as \"avgTime\", count(*) as count FROM expanded_defects WHERE duration_repair_sec > 0 GROUP BY label ORDER BY \"avgTime\" DESC LIMIT 5) x),\n            'logisticsStats', jsonb_build_object('pickup', jsonb_build_object('total', (SELECT pickup_total FROM stats), 'success', (SELECT pickup_success FROM stats), 'fail', (SELECT pickup_fail FROM stats)), 'carrier', jsonb_build_object('total', (SELECT carrier_total FROM stats), 'success', (SELECT carrier_success FROM stats), 'fail', (SELECT carrier_fail FROM stats))),\n            'outsourcedStats', jsonb_build_object('total', (SELECT outsourced_total FROM stats), 'success', (SELECT outsourced_success FROM stats), 'fail', (SELECT outsourced_fail FROM stats), 'returns', (SELECT outsourced_returns FROM stats)),\n            'internalStats', jsonb_build_object('total', (SELECT internal_total FROM stats), 'success', (SELECT internal_success FROM stats), 'fail', (SELECT internal_fail FROM stats))\n        ) INTO v_result;\n\n    RETURN v_result;\nEND;\n"},{"routine_name":"log_ticket_changes","routine_definition":"\nBEGIN\n    IF (TG_OP = 'UPDATE') THEN\n        IF NEW.status <> OLD.status THEN\n            INSERT INTO public.ticket_logs (ticket_id, action, details, user_name)\n            VALUES (NEW.id, 'Alteração de Status', 'De ' || OLD.status || ' para ' || NEW.status, 'Sistema');\n        END IF;\n    ELSIF (TG_OP = 'INSERT') THEN\n         INSERT INTO public.ticket_logs (ticket_id, action, details, user_name)\n         VALUES (NEW.id, 'Criado', 'Chamado aberto', NEW.created_by_name);\n    END IF;\n    RETURN NEW;\nEND;\n"},{"routine_name":"get_operational_alerts","routine_definition":"\nDECLARE\n    v_workspace_id UUID;\n    v_user_id UUID;\n    v_role TEXT;\n    v_result JSONB;\nBEGIN\n    -- 1. SECURITY: Determine Workspace Context\n    v_role := auth.role();\n    v_user_id := auth.uid();\n\n    IF v_role = 'authenticated' THEN\n        -- Admin: Get workspace from workspace ownership\n        -- Optimization: If p_workspace_id is passed, check if owner owns it. If not passed, find default.\n        IF p_workspace_id IS NOT NULL THEN\n             SELECT id INTO v_workspace_id FROM public.workspaces WHERE id = p_workspace_id AND owner_id = v_user_id;\n             IF v_workspace_id IS NULL THEN RAISE EXCEPTION 'Acesso negado: Workspace inválido para este admin.'; END IF;\n        ELSE\n             SELECT id INTO v_workspace_id FROM public.workspaces WHERE owner_id = v_user_id LIMIT 1;\n        END IF;\n    ELSE\n        -- Employee (anon): Get workspace from Token (IGNORE p_workspace_id)\n        SELECT workspace_id INTO v_workspace_id FROM public.current_employee_from_token();\n    END IF;\n\n    IF v_workspace_id IS NULL THEN\n        RAISE EXCEPTION 'Acesso negado: Workspace não identificado ou token inválido.';\n    END IF;\n\n    -- 2. QUERY LOGIC (Using v_workspace_id)\n    -- Calculate operational buckets\n    SELECT jsonb_build_object(\n        'pendingBudgets', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.created_at ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status = 'Analise Tecnica' -- Or specific flow for budgets? \"Aberto\" -> \"Analise\" -> \"Aprovacao\"\n              -- Assuming logic: Needs budget sent. Usually means 'Aprovacao' but budget_status is null/pending?\n              -- Adjusting to likely logic: Status 'Aprovacao' and budget not sent yet?\n              -- Or is it 'Analise Tecnica' finished?\n              -- Let's stick to standard buckets inferred from context or previous logic if available.\n              -- Re-implementing standard logic:\n              -- \"Orçamento Pendente\": Status 'Aprovacao' AND budget_status IS NULL (or 'Pendente')\n              AND t.status = 'Aprovacao'\n              AND (t.budget_status IS NULL OR t.budget_status = 'Pendente')\n              AND t.deleted_at IS NULL\n        ),\n        'waitingBudgetResponse', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.budget_sent_at ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status = 'Aprovacao'\n              AND t.budget_status = 'Enviado'\n              AND t.deleted_at IS NULL\n        ),\n        'pendingPickups', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.deadline ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status = 'Retirada Cliente'\n              AND t.pickup_available = FALSE -- Not yet marked available? Or maybe it is available?\n              -- Usually \"Solicitar Retirada\" means they are ready but client not notified?\n              -- Actually, if pickup_available is true, they are ready.\n              -- Let's assume pendingPickups means \"Ready for Pickup/Delivery\"\n              -- Actually the dashboard logic says: \"Pickups to Notify / Logistics Pending\"\n              -- So status 'Retirada Cliente' and NOT pickup_available?\n              -- Or status 'Retirada Cliente' generally.\n              AND t.deleted_at IS NULL\n        ),\n        'urgentAnalysis', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.analysis_deadline ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status IN ('Aberto', 'Analise Tecnica')\n              AND t.analysis_deadline < (now() + interval '4 hours')\n              AND t.deleted_at IS NULL\n        ),\n        'delayedDeliveries', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.deadline ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status NOT IN ('Retirada Cliente', 'Finalizado')\n              AND t.deadline < now()\n              AND t.deleted_at IS NULL\n        ),\n        'priorityTickets', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.created_at ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.priority_requested = TRUE\n              AND t.status NOT IN ('Finalizado')\n              AND t.deleted_at IS NULL\n        ),\n        'pendingPurchase', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.created_at ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status = 'Compra Peca'\n              AND (t.parts_status IS NULL OR t.parts_status = 'Pendente')\n              AND t.deleted_at IS NULL\n        ),\n        'pendingReceipt', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.parts_purchased_at ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status = 'Compra Peca'\n              AND t.parts_status = 'Comprado'\n              AND t.deleted_at IS NULL\n        ),\n        'pendingTech', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.created_at ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status = 'Aberto'\n              -- AND t.technician_id IS NULL -- Maybe? Or just any open ticket.\n              AND t.is_outsourced = FALSE\n              AND t.deleted_at IS NULL\n        ),\n        -- Logistics\n        'pendingTracking', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.pickup_available_at ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status = 'Retirada Cliente'\n              AND t.delivery_method = 'carrier'\n              AND t.tracking_code IS NULL\n              AND t.deleted_at IS NULL\n        ),\n        'pendingDelivery', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.pickup_available_at ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status = 'Retirada Cliente'\n              AND t.pickup_available = TRUE -- Ready\n              -- Includes both Pickup (waiting for client) and Carrier (waiting for arrival)\n              AND t.deleted_at IS NULL\n        ),\n        -- Outsourced\n        'pendingOutsourced', (\n            SELECT COALESCE(jsonb_agg(t ORDER BY t.outsourced_deadline ASC), '[]'::jsonb)\n            FROM public.tickets t\n            WHERE t.workspace_id = v_workspace_id\n              AND t.status = 'Terceirizado'\n              AND t.deleted_at IS NULL\n        )\n    ) INTO v_result;\n\n    RETURN v_result;\nEND;\n"},{"routine_name":"get_client_ticket_details_public","routine_definition":"\nBEGIN\n  RETURN QUERY\n  SELECT\n    t.id,\n    t.os_number,\n    t.device_model,\n    t.status,\n    t.deadline,\n    t.priority_requested,\n    t.pickup_available,\n    t.created_at,\n    w.whatsapp_number,\n    w.tracker_config,\n    t.delivery_method,\n    t.carrier_name,\n    t.tracking_code\n  FROM public.tickets t\n  JOIN public.workspaces w ON w.id = t.workspace_id\n  WHERE\n    t.id = p_ticket_id\n    AND t.public_token = p_public_token\n    AND t.deleted_at IS NULL;\nEND;\n"},{"routine_name":"get_client_ticket_details","routine_definition":"\nBEGIN\n    RETURN QUERY\n    SELECT\n        t.id,\n        t.os_number,\n        t.device_model,\n        t.status,\n        t.deadline,\n        t.priority_requested,\n        t.pickup_available,\n        t.created_at,\n        w.whatsapp_number,\n        w.tracker_config,\n        t.delivery_method,\n        t.carrier_name,\n        t.tracking_code\n    FROM public.tickets t\n    JOIN public.workspaces w ON w.id = t.workspace_id\n    WHERE t.id = p_ticket_id;\nEND;\n"},{"routine_name":"reset_employee_password","routine_definition":"\nDECLARE\n    v_owner_id UUID;\nBEGIN\n    -- 1. Validate Admin Permissions\n    -- Check if the executing user (auth.uid()) is the owner of the workspace \n    -- associated with the target employee.\n    \n    SELECT w.owner_id INTO v_owner_id\n    FROM public.employees e\n    JOIN public.workspaces w ON e.workspace_id = w.id\n    WHERE e.id = p_employee_id;\n\n    IF v_owner_id IS NULL OR v_owner_id <> auth.uid() THEN\n        RAISE EXCEPTION 'Permissão negada. Apenas o administrador da empresa pode resetar senhas.';\n    END IF;\n\n    -- 2. Update Employee\n    UPDATE public.employees\n    SET \n        password_hash = crypt(p_new_password, gen_salt('bf')),\n        must_change_password = TRUE\n    WHERE id = p_employee_id;\n\n    -- 3. Revoke all active sessions\n    UPDATE public.employee_sessions\n    SET revoked_at = now()\n    WHERE employee_id = p_employee_id AND revoked_at IS NULL;\n\nEND;\n"},{"routine_name":"create_employee","routine_definition":"\nDECLARE\n    v_new_id UUID;\nBEGIN\n    INSERT INTO public.employees (workspace_id, name, username, password_hash, roles, must_change_password)\n    VALUES (\n        p_workspace_id, \n        p_name, \n        p_username, \n        crypt(p_password, gen_salt('bf')), \n        p_roles,\n        TRUE -- Always force password change on creation\n    )\n    RETURNING id INTO v_new_id;\n\n    RETURN v_new_id;\nEND;\n"},{"routine_name":"update_employee","routine_definition":"\nBEGIN\n    UPDATE employees\n    SET\n        name = p_name,\n        username = p_username,\n        -- Update hash only if password is provided\n        password_hash = CASE \n            WHEN p_password IS NOT NULL AND p_password <> '' \n            THEN crypt(p_password, gen_salt('bf')) \n            ELSE password_hash \n        END,\n        -- If password changed, maybe force change again? \n        -- Usually admin changing password means reset, so yes, let's force it if password is set.\n        must_change_password = CASE\n            WHEN p_password IS NOT NULL AND p_password <> '' THEN TRUE\n            ELSE must_change_password\n        END,\n        roles = p_roles\n    WHERE id = p_id;\nEND;\n"},{"routine_name":"get_employees_for_workspace","routine_definition":"\nBEGIN\n    RETURN QUERY\n    SELECT e.id, e.workspace_id, e.name, e.username, e.roles, e.created_at\n    FROM public.employees e\n    WHERE e.workspace_id = p_workspace_id\n    AND e.deleted_at IS NULL\n    ORDER BY e.created_at DESC;\nEND;\n"},{"routine_name":"can_manage_logo","routine_definition":"\nDECLARE\n  v_workspace_id text;\nBEGIN\n  -- Extract workspace_id from path (first segment)\n  -- Assumes path is \"workspaceId/...\"\n  v_workspace_id := split_part(p_name, '/', 1);\n\n  -- 1. Check if User is Owner (Supabase Auth)\n  IF auth.role() = 'authenticated' AND EXISTS (\n    SELECT 1 FROM public.workspaces\n    WHERE id::text = v_workspace_id\n    AND owner_id = auth.uid()\n  ) THEN\n    RETURN true;\n  END IF;\n\n  -- 2. Check if User is Employee (via Token)\n  -- current_employee_from_token() returns TABLE(employee_id, workspace_id, role)\n  -- We just need to check if the workspace_id matches.\n  IF EXISTS (\n    SELECT 1 FROM public.current_employee_from_token() t\n    WHERE t.workspace_id::text = v_workspace_id\n  ) THEN\n    RETURN true;\n  END IF;\n\n  RETURN false;\nEND;\n"},{"routine_name":"employee_change_password","routine_definition":"\nDECLARE\n    v_session RECORD;\n    v_employee RECORD;\n    v_new_token UUID;\nBEGIN\n    -- Validate Token\n    SELECT * INTO v_session\n    FROM public.employee_sessions\n    WHERE token = p_token\n      AND revoked_at IS NULL\n      AND expires_at > now();\n\n    IF v_session.id IS NULL THEN\n        RAISE EXCEPTION 'Sessão inválida ou expirada.';\n    END IF;\n\n    -- Get Employee\n    SELECT * INTO v_employee FROM public.employees WHERE id = v_session.employee_id;\n\n    -- Verify Old Password\n    IF v_employee.password_hash <> crypt(p_old_password, v_employee.password_hash) THEN\n        RAISE EXCEPTION 'Senha atual incorreta.';\n    END IF;\n\n    -- Update Password\n    UPDATE public.employees\n    SET password_hash = crypt(p_new_password, gen_salt('bf')),\n        must_change_password = FALSE\n    WHERE id = v_session.employee_id;\n\n    -- Revoke Old Session (Optional but recommended)\n    UPDATE public.employee_sessions SET revoked_at = now() WHERE id = v_session.id;\n\n    -- Create New Session\n    INSERT INTO public.employee_sessions (employee_id, expires_at)\n    VALUES (v_session.employee_id, now() + interval '30 days')\n    RETURNING token INTO v_new_token;\n\n    RETURN QUERY SELECT v_new_token;\nEND;\n"},{"routine_name":"validate_employee_session","routine_definition":"\nDECLARE\n    v_session RECORD;\nBEGIN\n    SELECT s.id, s.employee_id, e.workspace_id, e.roles\n    INTO v_session\n    FROM public.employee_sessions s\n    JOIN public.employees e ON e.id = s.employee_id\n    WHERE s.token = p_token\n      AND s.revoked_at IS NULL\n      AND s.expires_at > now();\n\n    IF v_session.id IS NOT NULL THEN\n        -- Update Activity\n        UPDATE public.employee_sessions SET last_seen_at = now() WHERE id = v_session.id;\n        \n        RETURN QUERY SELECT true, v_session.employee_id, v_session.workspace_id, v_session.roles;\n    ELSE\n        RETURN QUERY SELECT false, null::uuid, null::uuid, null::text[];\n    END IF;\nEND;\n"},{"routine_name":"employee_logout","routine_definition":"\nBEGIN\n    UPDATE public.employee_sessions\n    SET revoked_at = now()\n    WHERE token = p_token;\nEND;\n"},{"routine_name":"employee_login","routine_definition":"\nDECLARE\n    v_workspace_id UUID;\n    v_employee_record RECORD;\n    v_workspace_record RECORD;\n    v_token UUID;\nBEGIN\n    -- Find workspace\n    SELECT * INTO v_workspace_record FROM public.workspaces WHERE company_code = p_company_code;\n    IF v_workspace_record.id IS NULL THEN RAISE EXCEPTION 'Código da empresa inválido'; END IF;\n\n    -- Find employee\n    SELECT * INTO v_employee_record\n    FROM public.employees e\n    WHERE e.workspace_id = v_workspace_record.id\n    AND e.username = p_username\n    AND e.deleted_at IS NULL;\n\n    IF v_employee_record.id IS NULL THEN RAISE EXCEPTION 'Usuário inválido'; END IF;\n\n    -- Verify password\n    IF v_employee_record.password_hash = crypt(p_password, v_employee_record.password_hash) THEN\n        \n        -- Create Session\n        INSERT INTO public.employee_sessions (employee_id, expires_at)\n        VALUES (v_employee_record.id, now() + interval '30 days')\n        RETURNING public.employee_sessions.token INTO v_token;\n\n        -- Return Data\n        RETURN QUERY SELECT\n            v_token,\n            (to_jsonb(v_employee_record) || jsonb_build_object(\n                'workspace_name', v_workspace_record.name,\n                'company_code', v_workspace_record.company_code,\n                'tracker_config', v_workspace_record.tracker_config\n            )) as employee_json,\n            v_employee_record.must_change_password;\n    ELSE\n        RAISE EXCEPTION 'Senha incorreta';\n    END IF;\nEND;\n"},{"routine_name":"create_owner_workspace","routine_definition":" DECLARE v_workspace_id UUID; BEGIN IF auth.uid() IS NULL THEN RAISE EXCEPTION 'User not authenticated'; END IF; INSERT INTO public.workspaces (name, company_code, owner_id) VALUES (p_name, p_company_code, auth.uid()) RETURNING id INTO v_workspace_id; RETURN v_workspace_id; END; "},{"routine_name":"create_owner_workspace_and_profile","routine_definition":" DECLARE v_workspace_id UUID; BEGIN IF auth.uid() IS NULL THEN RAISE EXCEPTION 'User not authenticated'; END IF; INSERT INTO public.workspaces (name, company_code, owner_id) VALUES (p_name, p_company_code, auth.uid()) RETURNING id INTO v_workspace_id; INSERT INTO public.profiles (id, workspace_id, role) VALUES (auth.uid(), v_workspace_id, 'admin'); RETURN v_workspace_id; END; "}]
