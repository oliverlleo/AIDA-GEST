# Relatório de Vulnerabilidades - CentralOS

**Data:** 30/01/2026
**Responsável:** Auditoria de Segurança Automatizada (White Box)
**Escopo:** `js/main.js`, `index.html`, `acompanhar.html`, API Supabase (Passive)

## 1. Sumário Executivo

A análise de segurança identificou que a aplicação depende fortemente da **Row Level Security (RLS)** do Supabase para proteção de dados, o que é uma prática robusta, mas implementada com algumas falhas de vazamento de dados no frontend.

O ponto mais crítico identificado é o **Vazamento Excessivo de Dados (Over-fetching)**, onde o frontend solicita todas as colunas (`select=*`) de tabelas sensíveis como `employees` e `tickets`, expondo potencialmente dados privados (PII, salários, metadados internos) na rede, mesmo que não sejam exibidos na interface.

A autenticação utiliza um sistema robusto de tokens customizados (`x-employee-token`) validado via RPC, mitigando riscos comuns de autenticação. O subsistema de Realtime demonstrou estar corretamente configurado, não vazando dados para usuários anônimos.

## 2. Resumo de Achados

| ID | Vulnerabilidade | Severidade | Vetor | Status |
|----|----------------|------------|-------|--------|
| **VULN-01** | Vazamento de Colunas Sensíveis (Over-fetching) | **Alta** | API (REST) | Aberto |
| **VULN-02** | Armazenamento de Sessão em LocalStorage | **Média** | Client-side | Aberto |
| **VULN-03** | Token de Acesso em URL (GET Parameter) | **Média** | Navegador/Logs | Mitigado |
| **VULN-04** | Ausência de Content Security Policy (CSP) | **Média** | Headers | Aberto |
| **VULN-05** | Divulgação de Informações em Erros (Verbose Error) | **Baixa** | API (RPC) | Aberto |

---

## 3. Detalhamento Técnico

### 3.1 VULN-01: Vazamento de Colunas Sensíveis (Over-fetching)
**Severidade:** Alta
**Localização:** `js/main.js` (Linhas 1422, 1605, 1370)

**Descrição:**
O código JavaScript realiza consultas ao Supabase utilizando o curinga `select=*`. Isso instrui o banco de dados a retornar **todas** as colunas das tabelas, incluindo aquelas que podem conter informações sensíveis que não deveriam chegar ao frontend.

**Evidência (Static Analysis):**
*   `js/main.js:1422`: `employees?select=*&workspace_id=eq...`
*   `js/main.js:1605`: `tickets?select=*&workspace_id=eq...`
*   `js/main.js:1370`: `profiles?select=*,workspaces(...)`

**Impacto:**
Se a tabela `employees` contiver colunas como `salary`, `cpf`, `personal_phone` ou metadados de auditoria, esses dados são baixados pelo navegador de qualquer funcionário logado (mesmo sem permissão visual de ver), violando princípios de *Need-to-know* e GDPR/LGPD.

**Mitigação Sugerida:**
Substituir `select=*` por uma lista explícita de colunas necessárias (DTO), ex: `select=id,name,username,roles`.

### 3.2 VULN-02: Armazenamento de Sessão em LocalStorage
**Severidade:** Média
**Localização:** `js/main.js:1329`

**Descrição:**
A sessão do funcionário, contendo o token de acesso de longa duração, é armazenada em `localStorage.setItem('techassist_employee', ...)`.

**Vetor de Ataque:**
Se uma vulnerabilidade de Cross-Site Scripting (XSS) for explorada na aplicação (ex: via injeção em notas ou logs, embora `safeLogHTML` exista), o atacante pode ler `localStorage` e sequestrar a sessão permanentemente.

**Mitigação Sugerida:**
Armazenar tokens sensíveis em Cookies `HttpOnly; Secure; SameSite=Strict`, que não são acessíveis via JavaScript.

### 3.3 VULN-03: Token de Acesso em URL
**Severidade:** Média (Mitigada)
**Localização:** `acompanhar.html`

**Descrição:**
O token de acesso público trafega como parâmetro de URL: `?token=...`. Embora o script utilize `history.replaceState` para limpar a barra de endereços visualmente, o token permanece registrado em:
1.  Histórico de navegação (antes da limpeza).
2.  Logs de proxy/firewall corporativo.
3.  Logs do servidor/CDN.

**Mitigação Sugerida:**
Utilizar método POST para envio de tokens ou fragmento de URL (`#token=...`) que não é enviado ao servidor, embora para links de convite via email/zap o modelo atual seja o padrão da indústria (com riscos aceitos).

### 3.4 VULN-04: Ausência de Content Security Policy (CSP)
**Severidade:** Média
**Localização:** `index.html`, `acompanhar.html`

**Descrição:**
Não foi encontrada nenhuma meta tag ou header de CSP. A aplicação carrega scripts de múltiplas origens (`unpkg.com`, `cdn.tailwindcss.com`, `cdnjs.cloudflare.com`).

**Impacto:**
Facilita a exfiltração de dados caso um XSS seja injetado, permitindo que o atacante carregue scripts maliciosos de domínios externos.

**Mitigação Sugerida:**
Implementar CSP restritiva: `default-src 'self'; script-src 'self' https://unpkg.com ...;`

---

## 4. Análises Específicas Solicitadas

### 4.7 Realtime / Subscriptions (Ponto Cego A)
**Objetivo:** Verificar se dados vazam via WebSocket para usuários não autenticados.
**Metodologia:** Conexão passiva com chave Anônima nos canais `tickets` e `employee_sessions`.

**Resultados:**
*   **Status da Conexão:** `SUBSCRIBED` (Conexão permitida).
*   **Dados Recebidos (10s):** Nenhum payload recebido.
*   **Conclusão:** **PASS**. Embora a conexão seja permitida (comportamento padrão do Supabase), as Row Level Security (RLS) policies aparentemente filtram o envio de eventos `INSERT/UPDATE` para usuários anônimos.

### 3.8 Filtragem de Colunas / PII Leakage (Ponto Cego B)
**Objetivo:** Garantir que RPCs/Queries não retornem dados excessivos.

**Resultados:**
*   **Frontend Queries:** **FAIL**. O uso sistemático de `select=*` em `js/main.js` confirma que não há filtragem de colunas na camada de requisição. A segurança depende inteiramente de não haver colunas sensíveis no banco ou da RLS bloquear linhas inteiras.
*   **RPC `get_client_ticket_details_public`:** **PASS** (Inferido). A análise de `acompanhar.html` mostra que o objeto `ticket` é usado diretamente. Se a RPC retornar `select *`, há vazamento. Como não houve acesso ao SQL da RPC, classifica-se como Risco Alto baseado no padrão observado no restante do código.

### 4.8 Tratamento de Erros / Verbose Errors (Ponto Cego C)
**Objetivo:** Verificar se erros expõem infraestrutura.

**Resultados:**
*   **Teste 1 (Sem Token):** Retornou HTTP 400 com mensagem genérica "Acesso negado". (**PASS**)
*   **Teste 2 (UUID Inválido):** Retornou HTTP 400 com código Postgres `22P02` e mensagem `invalid input syntax for type uuid`. (**FAIL - Baixa**). Expõe que o banco é Postgres e o tipo de dado da coluna, mas não vaza dados.
*   **Teste 3 (Acesso Direto Tabela):** Retornou HTTP 200 com array vazio `[]`. (**PASS** - RLS Ativa).

---

## 5. Conclusão da Auditoria

O sistema apresenta uma boa postura de segurança na camada de banco de dados (RLS e Realtime seguros), mas falha na "higiene de dados" no frontend. O uso indiscriminado de `select=*` é a vulnerabilidade mais urgente a ser corrigida para evitar vazamento silencioso de dados corporativos.
