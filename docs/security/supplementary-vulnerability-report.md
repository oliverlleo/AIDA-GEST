# Relatório Suplementar de Segurança: Análises Focadas

**Data:** 30/01/2026
**Escopo:** Análises Adicionais (Realtime, PII Leakage, Tratamento de Erros)
**Restrições:** Testes realizados de forma passiva (sem alterações de estado).

Este relatório contém os resultados das três análises específicas solicitadas para aprofundar a auditoria de segurança.

---

## 1. O "Ponto Cego": Supabase Realtime (Websockets)

**Objetivo:** Verificar se o canal de Websockets (Realtime) respeita as políticas de RLS e impede o vazamento de stream de dados para usuários anônimos.

**O Risco:** Se um atacante (Anon) conseguir se inscrever em canais como `public:tickets` ou `public:employee_sessions`, ele poderia receber um stream contínuo de dados sensíveis (INSERT/UPDATE) sem estar autenticado.

**Metodologia de Teste (Passiva):**
Foi executado um script de teste utilizando a biblioteca `@supabase/supabase-js` com chave anônima (anon key), tentando subscrever aos canais:
*   `postgres_changes` em `public.tickets`
*   `postgres_changes` em `public.employee_sessions`

O script permaneceu conectado por 10 segundos observando o recebimento de eventos.

**Resultados:**
*   **Status da Subscrição:** `SUBSCRIBED` (O servidor aceitou a conexão do socket).
*   **Eventos Recebidos:** **Nenhum**.
*   **Snapshots Recebidos:** **Nenhum**.

**Conclusão (Seção 4.7):**
**PASS**. A tentativa de subscrição anônima foi bem-sucedida em termos de conexão, porém **nenhum evento foi recebido**. Isso confirma que o Supabase Realtime está respeitando corretamente as Row Level Security (RLS) policies configuradas no banco de dados, filtrando os eventos na origem antes de enviá-los ao cliente não autenticado.

---

## 2. Vazamento de Colunas Sensíveis (PII Leakage)

**Objetivo:** Garantir que as consultas realizadas pelo front-end não solicitem colunas desnecessárias que possam conter dados sensíveis (PII, hashes, salários, tokens).

**O Risco:** O uso de `.select('*')` no cliente JavaScript instrui a API a retornar todas as colunas da tabela. Mesmo que a interface não exiba esses dados, eles trafegam pela rede e ficam acessíveis via "Inspect Element" ou logs de rede, expondo dados como `password_hash`, `recovery_token`, ou `salary` se existirem na tabela.

**Metodologia de Teste (Análise Estática):**
Revisão do código fonte `js/main.js` em busca de padrões de consulta ao Supabase.

**Resultados:**
*   **Evidência:** Linha 1422 (aprox): `employees?select=*&workspace_id=eq...`
*   **Evidência:** Linha 1605 (aprox): `tickets?select=*&workspace_id=eq...`
*   **Evidência:** Linha 1370 (aprox): `profiles?select=*,workspaces(...)`

**Conclusão (Seção 3.8 - Overfetching):**
**FAIL (Risco Identificado).** O front-end utiliza sistematicamente `select('*')`.
**Impacto:** Se as tabelas `employees` ou `tickets` possuírem colunas sensíveis não protegidas por RLS de coluna (Column Level Security), esses dados estão sendo vazados para qualquer usuário logado.
**Mitigação Necessária:** Alterar as chamadas no front-end para selecionar colunas explícitas (ex: `.select('id, nome, cargo')`) ou garantir que uma View segura seja utilizada.

---

## 3. Tratamento de Erros (Information Disclosure)

**Objetivo:** Verificar se a API retorna mensagens de erro detalhadas que exponham a estrutura interna do banco de dados (nomes de constraints, queries SQL, stack traces).

**O Risco:** Mensagens de erro verbosas ("Verbose Error Messages") facilitam ataques de SQL Injection (Error-based) e reconhecimento de infraestrutura.

**Metodologia de Teste (Negative Testing):**
Foram realizadas chamadas intencionalmente inválidas à API REST:
1.  Chamada RPC sem token de autenticação (`x-employee-token`).
2.  Chamada RPC com parâmetro UUID inválido (fuzzing simples).

**Resultados:**
*   **Teste 1 (Sem Token):** Retornou HTTP 400.
    *   Body: `{"message": "Acesso negado: Workspace não identificado ou token inválido."}`
    *   Análise: Mensagem genérica e segura.
*   **Teste 2 (UUID Inválido):** Retornou HTTP 400.
    *   Body: `{"code":"22P02", "message":"invalid input syntax for type uuid: \"invalid-uuid-string\""}`
    *   Análise: Retornou o código de erro interno do PostgreSQL (`22P02`), revelando que o backend é Postgres e o tipo de dado esperado.

**Conclusão (Seção 4.8):**
**Misto (Baixo Risco).**
*   **Erros de Autenticação:** **PASS**. Retornam mensagens genéricas.
*   **Erros de Validação de Tipo:** **FAIL (Baixa Severidade)**. Expõem detalhes técnicos do banco de dados (PostgreSQL Error Codes), mas não vazam dados ou estrutura de tabelas/constraints críticas.
